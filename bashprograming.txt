Pemrograman Bash
Bash (born again shell) adalah bahasa tingkat tinggi yang hebat untuk administrasi sistem. Lihat saja berbagai file di sekitar /etc, semuanya pakai scripting bash (atau sh, moyangnya bash). Jadi anda harus menguasainya kalau mau hacking Linux. Walau harus diakui, syntax bash ini aneh-aneh. He he he ... mohon maklum, dirancangnya buat hacker-friendly, bukan user-friendly !

CARA MEMROGRAM
Untuk melakukan pemrograman Bash, yang anda perlukan hanya terminal dan sebuah editor teks untuk mengedit skrip-nya.
Membuat Skrip
Skrip dapat anda buat dengan mengeditnya memakai editor teks, misalnya GEdit (GUI) atau mcedit. Misalnya:

 $ mkdir $HOME/bin
 $ cd $HOME/bin
 $ mcedit hello.sh

Isi Skrip
Ini contoh isi scriptnya.

#!/bin/bash
# Baris pertama script bash harus seperti di-atas
# Selanjutnya baris dengan tanda # di depan adalah komentar
 
# Ini perintah yang akan dijalankan
echo "Hello newbie"
echo "Your shell is speaking here ..."

Menjalankan skrip
Setelah selesai diedit dan disimpan, file tersebut harus diubah modenya menjadi executable, baru dijalankan.

$ chmod +x hello.sh
$ ./hello.sh


bashrc
Skrip $HOME/.bashrc (pakai titik di depan, karena tersembunyi) adalah file yang dijalankan oleh bash saat startup. Jadi biasanya dipakai setting bash , misalnya sebagai berikut.

# Atur prompt
set PS1=
set PS1=
 
# Bikin supaya terminal colourfull
eval `dircolors -b` 
 
# Tambah path
export PATH=$PATH:~/bin

PEMROGRAMAN DASAR
Baik, sekarang kita mulai belajar berbahasa BASH.
Output
Pertama, tentu saja bagaimana bisa 'ngomong'. Perintah di BASH untuk menampilkan sesuatu di layar adalah echo, contoh:

#!/bin/bash
# File: bash1.sh
# Macam-macam output
 
# Output string, perhatikan petik dua dan petik satu
echo "Linus said: "
echo -n ' "See, you not only have to be a good coder to create a system like Linux, '
echo 'you have to be a sneaky bastard too ;-)" '


Data
Linus, "I will, in fact, claim that the difference between a bad programmer and a good one is whether he considers his code or his data structures more important. Bad programmers worry about the code. Good programmers worry about data structures and their relationships."
Data adalah suatu nilai yang bisa diolah oleh komputer. Asalnya mungkin dari masukan pemakai, dan nantinya akan ditampilkan ke pemakai. Dalam program, data bisa berupa konstanta, yaitu data yang tetap. Sementara itu Variabel adalah simbol yang menyimpan suatu data, dan bisa berubah.
Variabel Program

#!/bin/bash
# File : bash102.sh
 
# Mengisi variabel dengan konstanta
SISOP="Linux"
 
# Tampilkan isinya
echo "Saya suka" $SISOP
 
# Ubah isinya, tampilkan
SISOP="Open Source"
echo "dan semua" $SISOP


Environment Variabel
Salah satu keistimeaan BASH adalah, dia punya environment variabel. Anda bisa melihat semua variabel tersebut dengan perintah set

$ set | less

Dan mendefinisikannya dengan perintah export

$ export GELAR="Newbie"


Dalam skrip, variabel tersebut bisa langsung dipakai, misalnya:

#!/bin/bash
 
# Tampilkan variabel environment
echo "Hi " $GELAR $USERNAME

Input
Linus, "The only limiting factor of the Linux operating system is its user."
Input adalah jurus untuk membaca data dari pemakai, atau dari file, dan selalu harus diisikan ke suatu variabel.
Input Pemakai
Untuk menerima masukan dari pemakai, perintahnya adalah read .

#!/bin/bash
echo "Hai, siapa namamu ?"
read NAME
echo "Salam kenal" $NAME ", saya " $SHELL!


Input Program
BASH, ternyata juga bisa menerima input dari program lain, dan caranya sangat gampang. Misalkan skrip kita ingin tahu waktu sekarang. Untuk itu sudah ada program bernama date, silahkan dicoba dulu:

$ date
Sun Feb 28 02:34:20 WIT 2010

$ date --help 

$ date +%H:%M:%S
02:36:22

$ date +%d-%m-%Y
28-02-2010

Nah, sekarang mari buat skrip menerima masukan dari program date.

#!/bin/bash
 
 # menerima masukan dari program lain, perhatikan tanda kutipnya
 JAM=`date +%H`
 MENIT=`date +%M`
 echo "Sekarang jam" $JAM:$MENITroot@igos-desktop:~/bin#


Operasi
Linus, "Let's put it this way: if you need to ask a lawyer whether what you do is "right" or not, you are morally corrupt. Let's not go there. We don't base our morality on law."
Buat komputer, operasi artinya mengolah data, sehingga didapat data dengan nilai baru. Masalahnya disini, ada berbagai jenis data. Yang paling umum adalah huruf dan angka. Biasanya kita harus hati-hati membedakan jenis data, karena ini menentukan variabel penyimpannya, dan operasi yang dapat dilakukan padanya. Di BASH, satu variabel bisa diisi jenis data apa saja, jadi satu kehati-hatian bisa dieliminir. Namun soal operasi, tetap harus extra hati-hati.
Operasi String
Sebagai bahasa skripting, jenis data string (untaian huruf) adalah makanan utama buat BASH. Karena itu operasinya mudah dan enak ditulis. Contoh:

#!/bash
 
# Beberapa variabel string
DISTRO1="UBuntu"
DISTRO2="Slackware"
DISTRO3="Fedora"
 
# Ini menggabung string, pakai tanda kutip berbeda
S1="$DISTRO1 $DISTRO2 $DISTRO3, semuanya Linux !"
S2='$DISTRO1 $DISTRO2 $DISTRO3, pokoknya Linux !'
 
# Hati-hati kalau nama variabel tersambung tanpa spasi
S3="$DISTRO1-Linux !"
S4="$DISTRO2Linux !"
S5='${DISTRO3}Linux !'
 
echo $S1
echo $S2
echo $S3
echo $S4
echo $S5


Operasi Aritmatika
BASH juga bisa berhitung mengolah data angka. Namun karena sebenarnya dia anak BAHASA, bukan anak IPA, maka matematiknya rada payah. Kita jajal yuk.

#!/bin/bash
 
# Ayo berhitung ...
echo "1+1=" 1+1
echo "1+2=" $[2+1]
echo "1*3=" $[1*3]
echo "1/4=" $[1/3]

Pinter tidak si BASH ?

Operasi Logika
Data logika adalah data yang nilainya hanya BENAR (true, 1) atau SALAH (false, 0). Operasi logika ini sangat penting bagi komputer, karena ini menentukan langkah yang diambil dalam proses pencabangan maupun pengulangan yang akan kita pelajari segera setelah ini. Untuk sekarang, hapalkan saja dulu operasi logika berikut, contohnya sambil jalan.
Pencabangan
Linus, "The fact is, there aren't just two sides to any issue, there's almost always a range or responses, and "it depends" is almost always the right answer in any big question. "
Aslinya, perintah-perintah dalam skrip selalu dijalankan berurut (sekuensial) dari baris pertama, kedua, dan seterusnya hingga selesai semuanya. Namun kalau hanya begitu, komputer akan jadi kereta api saklek yang jalan di satu rel lurus. Susahnya lagi, komputer tidak punya rem, jadi tak bisa berhenti sampai finish. Hidup kan tidak begitu. Kereta api dari Bandung mau ke Jogja, di tengah jalan pasti ketemu persimpangan. Belok kiri masuk Purwakarta, kalau terus ke Jogja. Pilih mana ?
If
If adalah perintah pencabangan yang akan mengeksekusi blok perintah tertentu, berdasarkan kondisi logika (benar / salah) tertentu. Berikut ini adalah sebuah skrip sederhana yang menerapkan konstruksi di atas :

#!/bin/bash
 
echo -n "Masukkan sebuah password : "
read password
 
if [ $password == eureka ]; then
  echo "you're right."
fi
 
# Kalau mau aman ... gunakan tanda petik pada argumen
if [ "$password" == "eureka" ]; then
  echo "you're right, and so am I."
fi

Tampilan setelah skrip di atas dijalankan adalah sebagai berikut :

Masukkan sebuah password : eureka
youre right.

Coba masukkan password dengan lebih dari dua kata, misal linux oke.

Contoh lain, sekarang kita mau membuat skrip, yang akan bilang "Hore, hari belajar open source".

#!/bin/bash
 
echo "Hore, hari belajar open source."

Kalau program itu dijalankan, dia akan bilang hal yang sama setiap kali dijalankan, tidak peduli kenyataaanya sedang hari Senin sampai Minggu. Well, bagus kalau memang begitu. Namun kalau belajarnya cuma hari Sabtu, bagaimana dong ? Here comes the "if".

#!/bin/bash
 
# Hari padepokan, gunakan "Sabtu" kalau locale Indonesia
HARI_PADEPOKAN="Saturday"
 
# Hari ini, tanya pada program date
HARI_INI=`date +%A`
 
echo "Ini hari" $HARI_INI
 
# Pencabangan, periksa apakah HARI_INI sama dengan HARI_PADEPOKAN
if [ $HARI_INI == $HARI_PADEPOKAN ]; then
  # bagian ini hanya akan dijalankan kalau pemeriksaan oleh if BENAR 
  echo "Hore ... saatnya belajar open source !!!"
fi
# kalau SALAH, langsung loncat ke sini

Nah, program di atas sudah lebih pintar. Kita tambah sedikit pintarnya ...

#!/bin/bash
 
# definisi hari, gunakan "Sabtu" dan "Minggu" kalau locale Indonesia
HARI_PADEPOKAN="Saturday"
HARI_LIBUR="Sunday"
 
# Hari ini, tanya pada program date
HARI_INI=`date +%A`
 
echo "Ini hari $HARI_INI"
 
# Pencabangan dengan tiga kasus:
if [ $HARI_INI == $HARI_PADEPOKAN ]; then
  echo "Hore ... hari belajar open source !!!"
elif [ $HARI_INI == $HARI_LIBUR ]; then
  echo "Hari libur :D"
else
  echo "Ayo kerja, semangat !!!"
fi


Case
Case adalah pencabangan khusus untuk banyak kondisi pemilihan, yang lebih digunakan dibanding perintah if/elif/else.
Misalkan kita ingin menampilkan musim di Indonesia:

    Juni - September : musim kemarau
    Desember - Maret : musim hujan
    sisanya : musim pancaroba

Artinya, ada 12 kasus pemeriksaan, bayangkan repotnya kalau pakai if/elif/else. Ini kalau pakai case:

#!/bin/bash
 
# Bulan, tanya pada program date
BULAN_INI=`date +%B`
 
echo "Bulan: " $BULAN_INI
 
# Pencabangan pakai case
case $BULAN_INI in
  Ju??|'August'|'September')      # pilihan pertama
      echo "Musim kemarau"
      ;;                          # akhiri dengan dua titik koma
  'December'|*ry|'March')         # pilihan kedua
      echo "Musim hujan"
      ;;
  *)                              # pilihan sisa
      echo "Musim pancaroba"
      ;;
esac

Perhatikan bahwa:

    setiap baris pilihan harus diberi tanda kurung ), baru aksi
    tiap pilihan dipisah dengan tanda garis tegak |
    Pilihan bisa pakai wild card * (contoh *ry), maupun ? (contoh Ju??).
    setelah semua aksi, diakhiri dengan dua titik koma ;;


Pengulangan
Linus, "We all know Linux is great … it does infinite loops in 5 seconds"
Pengulangan adalah jurus pemrograman dimana satu blok perintah bisa dilakukan berulang-ulang. Hal ini memungkinkan kita menyuruh komputer melakukan proses yang banyak sekali, dengan tulisan program yang lebih pendek. Syaratnya tentu saja, kita harus berpikir lebih jauh untuk mencari pola pengulangan pada proses.
For
For adalah pengulangan untuk data yang kita sudah tahu sebelumnya. Misalkan kita akan menulis beberapa distro Linux

#!/bin/bash
#
 
echo "Distro-distro Linux:"
 
# Ini cara tak pakai loop
echo Linux from Scratch
echo Gento
echo Damn Small Linux
echo Puppy
 
# Ini sudah pakai loop for
for DISTRO in Slackware OpenSUSE Fedora UBuntu; do   
   echo $DISTRO
done
# batas blok


Bisa juga untuk rentang nilai (angka) tertentu, misalnya kita mau membuat penggaris sepanjang 40 karakter, tiap 10 karakter ada tanda angkanya.

#!/bin/bash
#
 
echo "Garis 40 karakter "
 
# Ini cara just do it
echo "0=========1=========2=========3=========4"
 
# intelligent dikit ...
echo -n '0'
for N in {1..4}; do
   for M in {1..9}; do
      echo -n '-'
   done
   echo -n $N
done
echo


While
While adalah pengulangan yang berhentinya berdasar ekspresi logika, cocok untuk suasana dimana kita tidak tahu pasti kapan berhentinya. Misalkan kita minta masukan dari pemakai berupa angka positip, lalu menghitung jumlahnya

#!/bin/bash
#
 
SUM=0
COUNT=0
echo -n "Masukkan angka, akhiri dengan -1 : "
read N
 
# loop pakai while
while [[ N -gt 0 ]]; do
   let SUM=$SUM+$N
   let COUNT=$COUNT+1
   echo -n "Angka : "
   read N
done
# batas blok
echo 
echo "Banyak data = $COUNT"
echo "Jumlah = $SUM"

Berkas:Bash28.png Berkas:Bash29.png
Subrutin
Linus, "If you need more than 3 levels of indentation, you're screwed anyway, and should fix your program. "
Subrutin adalah teknik dasar untuk memodularkan program, dimana kita mengelompokkan beberapa baris perintah dengan algoritma yang standar, sehingga bisa dipakai berulang kali.
Misal saja kita ingin membuat tampilan pohon sebelah berikut:

*
**
***
****
||
||

Maka program kita:

#!/bin/bash
 
# ini sub rutin menggambar garis
gambar_garis() {
    for N in `seq 1 $1`; do
 echo -n "$2"
    done
    echo
}
 
# rutin utama, menggambar pohon 
# dengan memanggil subrutin gambar_garis
gambar_garis 1 '*'
gambar_garis 2 '*'
gambar_garis 3 '*'
gambar_garis 4 '*'
gambar_garis 2 '|'
gambar_garis 2 '|'

Berkas:Bash30.png Berkas:Bash31.png
Perhatikan pada subrutin

    Kita harus memberi nama (dalam hal ini gambar_garis), lalu tanda ().
    Blok subrutin memakai kurung kurawal { ... }.
    Subrutin bisa menerima argumen, bernama $1, $2, $3 dan seterusnya.

Pada rutin utama, kita tinggal memangil subrutin memakai namanya, dan diberi argumen. Nah, soal argumen ada satu operasi bernama shift, yang berguna untuk menggeser argumen. Langsung saja contohnya:

#!/bin/bash
 
# sub rutin menggambar garis
gambar_garis() {
    for N in `seq 1 $1`; do
 echo -n '*'
    done
    echo
}
 
# sub rutin menggambar pohon
gambar_pohon() {
    M=$1           # ambil argumen pertama
    while [ "$M" ]; do
 gambar_garis $M
 shift      # geser argumen
 M=$1       # ambil argumen berikutnya 
    done
}
 
# rutin utama
# panggil gambar_pohon dengan banyak argumen
gambar_pohon 1 2 3 4 5 2 2

Berkas:Bash32.png Berkas:Bash33.png
Array
Array adalah struktur data, dimana banyak data dikelompokkan berderet dan bisa diakses dengan indeks tertentu. Ini sangat banyak gunanya. Sekedar contoh sederhana:

#!/bin/bash 
 
# definisikan array. 
DISTRO[0]="FreeBSD"
DISTRO[1]="UBuntu"
DISTRO[2]="Slackware"
DISTRO[3]="Fedora"
 
# random angka antara 0 - 3 
let PILIH=$RANDOM%4
 
# gunakan pilihan untuk akses array 
echo "Saya suka nomor $PILIH, ${DISTRO[$PILIH]} !"

Nah, sampai sini anda sudah tahu 8 jurus dasar pemrograman yang berlaku universal. Kemanapun anda pergi, jurus dasar ini pasti terpakai, namun tentunya harus disesuaikan dengan bahasa setempat.
Berkas:Bash34.png Berkas:Bash35.png
PEMROGRAMAN LANJUT
Sekarang kita mulai fitur-fitur pemrograman yang KHAS shell. Bahasa lain belum tentu punya.
Source
Skrip bash bisa memanggil skrip bash lain. Misalkan saja buatlah skrip member.conf berikut

#!/bin/sh

NAMA="Tux"
GELAR="Pinguin of Linux"

echo "Pemanggil : $BOSS"

Perhatikan bahwa isi file ini adalah skrip bash, namun dia juga sebagai file teks berisi konfigurasi. Ini trik yang biasa dipakai di shell programming.
Mari kita buat skrip utama berikut

#!/bin/bash
 
BOSS="Linus"
 
# baca file konfigurasi
source member.conf
 
# tulis
echo "Anggota adalah "
echo "Nama  :" $NAMA
echo "Gelar :" $GELAR

Perhatikan bagaimana variabel saling dikenali di kedua skrip. Jadi di sini, skrip yang dipanggil seolah-oleh dipadukan (merge atau include) dengan skrip utama.
Berkas:Bash36.png Berkas:Bash37.png
Sub Program
Skrip bash bisa memanggil program lain, termasuk memanggil skrip bash. Misalkan

#!/bin/sh
 
BOSS='Linus'
 
# memanggil program cat untuk membaca file member.conf
echo "Isi member.conf"
cat member.conf
 
# memanggil program 
echo "================"
echo "Menjalankan program member.conf"
./member.conf
 
# tulis
echo "Setelah menjalankan member.conf"
echo "Nama  :" $NAMA
echo "Gelar :" $GELAR

Pada program terakhir ini, mengapa Nama dan Gelar kosong ? Demikian pula kenapa skrip member.conf tidak menampilkan pemanggil ? Bagaimana memperbaikinya ?
Berkas:Bash38.png Berkas:Bash39.png
Input Redirection
Biasanya, suatu program menerima masukan dari keyboard. Di shell, kita bisa mengganti keyboard ini dengan file. Coba buat skrip berikut:

#!/bin/bash
# cat-var.sh
# program yang menerima masukan baris-baris string
# lalu mencetaknya kalau baris mengandung tanda =
 
while read LINE; do 
    if [[ "$LINE" == *=* ]]; then
 echo $LINE
    fi
done

Simpan file tersebut dengan nama cat-var.sh, lalu panggil sebagai berikut

$ cat member.conf
$ ./cat-var.sh < member.conf

Berkas:Bash40.png Berkas:Bash41.png
Output Redirection
Pasangan dengan Input redirection, shell memungkinkan output dari suatu program langsung masuk ke file, bukan ditampilkan ke layar. Jadi coba saja panggil

$ ./cat-var.sh < member.conf > member.out
$ cat member.out

Kalau output ingin ditambahkan ke file (bukannya menindis file), maka gunakan dua tanda >>. Misalnya:

$ ./cat-var.sh < member.conf > member.out
$ cat member.out
$ ./cat-var.sh < member.conf >> member.out
$ cat member.out

Pipe
Pipe adalah redirection dari program ke program (bukan dari file ke program). Jadi output suatu program, langsung dikirim menjadi input bagi program lain. Coba saja lah, biar jelas.

$ cat member.conf
$ cat member.conf | cat-var.sh

PROGRAM BANTU
Bash saja tidak akan terlalu banyak gunanya, namun dengan adanya redirection dan pipe, the power of shell programming datang dari berbagai utilitas kecil, yang bisa disambung-sambung. Untuk latihan ini, kita akan pakai salinan file /etc/passwd

$ cp /etc/passwd .
$ cat passwd

Isinya kira-kira:

xfs:x:43:43:X Font Server:/etc/X11/fs:/sbin/nologin
mysql:x:27:27:MySQL Server:/var/lib/mysql:/bin/bash
kocil:x:500:500:Kocil:/export/home/kocil:/bin/bash
admin:x:501:501:Administrator:/export/home/admin:/bin/bash

Seperti kita ketahui bersama (kalau belum pura-pura tahu saja), file /etc/passwd adalah daftar dari semua pemakai di Linux. Formatnya adalah:

nama_user : x (password) : user_id : group_id : nama_lengkap : home : shell 



Cat, Head, Tail
Tiga program kucing, kepala, dan ekor ini beguna untuk melihat isi file. Coba saja:

$ head -n 2 passwd
$ tail -n 3 passwd

dalam skrip bisa kita manfaatkan seperti contoh berikut:

#!/bin/bash
# periksa.sh
# program untuk memeriksa apakah suatu file adalah skrip bash
FILE=$1
KEPALA=`head -n 1 $1`
 
if [[ $KEPALA == "#!/bin/bash" ]]; then
   echo "File $1 adalah skrip BASH"
else
   echo "Bukan skrip bash"
fi

Coba gunakan skrip tersebut:

$ ./periksa.sh  passwd
$ ./periksa.sh  member.conf

Cut
Cut adalah program untuk memisahkan kolom-kolom pada sebuah baris. Coba panggil

$ tail -n 1 passwd
$ tail -n 1 passwd | cut -f 1 -d ':'
$ tail -n 1 passwd | cut -f 5 -d ':'

Artinya, program tail akan mengirim baris terakhir lewat pipe ke program cut. Selanjutnya program cut menampilkan luaran sesuai option-nya, yaitu:

    f : nomor field (kolom)
    d : delimiter (pemisah) kolom

Mari kita pakai untuk membuat program yang membuat tabel user dengan bagus.

#!/bin/bash                                                                     
# list-passwd.sh                                                                  
# Menampilkan user dari file /etc/passwd dengan rapi                            
# hanya yang shell-nya bash                                                     
 
# Untuk memformat kolom dengan bagus, pakai jurus output printf                                           
FORMAT="%-16s %s\n"                                                                               
printf "$FORMAT" "Login" "Nama Lengkap"                                         
 
while read LINE; do                                                             
   SH=`echo $LINE | cut -f 7 -d ':'`                                            
   if [[ $SH == /bin/bash ]]; then                                              
     LOGIN=`echo $LINE | cut -f 1 -d ':'`                                       
     NAMA=`echo $LINE | cut -f 5 -d ':'`                                        
     printf "$FORMAT" "$LOGIN" "$NAMA"                                          
   fi                                                                           
done

Program ini kita panggil

$ list_passwd.sh < passwd

Grep
Grep adalah program bantu untuk mencari isi file teks tertentu. Silahkan dicoba dulu:

$ grep "/bin/bash" < passwd

Nampak bahwa grep menerima masukan lewat input redirection, dan membacanya baris per baris. Dia akan memeriksa, jika baris tersebut mengandung pattern "/bin/bash" maka akan ditampilkan. Untuk sebaliknya, coba:

$ grep -v "/bin/bash" < passwd

Nah, dengannya program sebelumnya bisa kita sederhanakan jadi

#!/bin/bash                                                                     
# ls-passwd.sh                                                                  
# Menampilkan user dari file /etc/passwd dengan rapi                            
# hanya yang shell-nya bash                                                     
 
FORMAT="%-16s %s\n"                                                             
 
printf "$FORMAT" "Login" "Nama Lengkap"                                         
grep bin/bash | while read LINE; do                                             
   LOGIN=`echo $LINE | cut -f 1 -d ':'`                                         
   NAMA=`echo $LINE | cut -f 5 -d ':'`                                          
   printf "$FORMAT" "$LOGIN" "$NAMA"                                            
done

Mencobanya sama seperti sebelumnya:

$ grep_passwd.sh < passwd

Awk
[Awk] itu nama yang aneh. Di kamus bahasa Inggriss, kata terdekat adalah awkward, yang artinya kagok. Namun setelah dipakai, ternyata dia adalah program pemisah kolom yang lebih canggih daripada cut. Coba saja:

awk -F: '{print ($1,  " = ", $5);}' < passwd 

Di sini:

    Option -F mendefinisikan pemisah (delimiter)
    '{print ($1, " = ", $5);}' adalah perintah yang akan dijalankan untuk semua baris masukan (yaitu file passwd)

Rahasia pemakaian awak ada di perintah. Terlihat bahwa perintahnya adalah

    print, artinya mencetak sesuatu
    $1 dan $5, ternyata adalah nomor kolom (yang telah dipisah-pisah oleh awk, berdasar delimiter
    " = " adalah string biasa

Awk juga kenal printf, jadi kita bisa buat keluaran mirip seperti program sebelumnya hanya dengan perintah:

awk -F: '{printf("%-20s %-40s", $1, $5);}' < passwd 

Wah masih kurang headernya. Jangan nyepelein awk. Lihat nih:

awk -F: 'BEGIN{print "Login      Nama";} {printf("%-10s %-40s\n", $1, $5);}' < passwd 

Masih banyak lagi kebisaan awk. Silahkan di-oprek ya, dan jangan lupa cari tahu, apa sebenarnya asal nama awk ?
Sed
Sed, kependekan dari stream editor, adalah program yang mampu mengubah isi file teks. Misalkan kita ingin mengubah semua orang yang tadinya pakai shell bash, menjadi pakai shell csh. Perintahnya adalah:

$ sed 's!/bin/bash!bin/csh!' passwd

Lihat baik-baik keluarannya. Apakah masih ada yang pakai shell bash ? Tak ada kan. Namun apa artinya argumen 's!/bin/bash!bin/csh!' ? Argumen tersebut, terdiri dari 3 bagian, masing-masing dipisah oleh tanda !. Bagian pertama (s) adalah perintah subtitusi (ganti). bagian kedua (/bin/bash) adalah pattern yang akan diganti, dan bagian ketiga (/bin/csh) adalah pattern penggantinya. Singkat kata, cara kerjanya adalah search dan replace ALL. Semua baris akan diubah, perhatikan itu !
Lebih dari itu, sesungguhnya sed sangat powerfull. Sangat dianjurkan untuk mempelajarinya lebih jauh.
Dialog
Sejauh ini, tampilah program bash hanya berdasar jurus output echo yang .... plain. Program bantu [dialog], akan mengubah hal itu. Mari kita coba (install dulu kalau belum ada)

sudo apt-get install dialog
dialog --title "Dialog" --msgbox "Hallo dunia" 5 20

Contoh lebih lanjut, lihat bagian aplikasi.
Aplikasi
Nah, sekarang kita coba beberapa aplikasi bash yang (semoga) menarik.
Sysinfo
Ada beberapa program di Linux yang bisa menampilkan informasi sistem, misalnya uname, vmstat, dmesg, lspci, dll. Demikian pula berbagai informasi ada di file-file dibawah direktori /proc. Coba saja satu per satu

$ uname -a
$ vmstat
$ lspci
$ cat /proc/cpuinfo
$ cat /proc/meminfo

Nah, kalau mau tahu informasi komputer dengan cepat dan kompak, buat skrip berikut:

#!/bin/bash
 
echo "Informasi Sistem"                                                         
 
# informasi perangkat keras                                                     
# Pada Linux bisa dibaca dari file-file dibawah /proc                           
echo "++ Perangkat keras "                                                      
CPU=`grep "model name" /proc/cpuinfo | head -n 1 | cut -f 2 -d ':'`             
RAM=`grep "MemTotal" /proc/meminfo | cut -f 2 -d ':'`                           
 
echo " |- CPU : " $CPU                                                          
echo " |- RAM : " $RAM                                                          
 
echo "++ Sistem Operasi "                                                       
# informasi sistem operasi                                                      
OS=`uname -sr`                                                                  
 
echo " |- OS : " $OS                                                            
echo " |- Shell : " $SHELL

Terminal Warna Random
Coba baca dulu artikel Terminal_ATerm. Skrip berikut meluncurkan aterm dengan warna random.

#!/bin/bash 
 
# definisikan array. 
WARNA[0]="red"
WARNA[1]="green"
WARNA[2]="yellow"
WARNA[3]="blue"
WARNA[4]="magenta"
WARNA[5]="cyan"
 
# random angka antara 0 - 3 
let PILIH=$RANDOM%6
 
# luncurkan aterm dengan LANG=C  agar mc bekerja benar (bug di Ubuntu)
LANG=C aterm -tint ${WARNA[$PILIH]}

Terminal Warna Urut
Sekarang kita ingin aterm-nya muncul dengan warna berurut. Untuk itu, warna terakhir kita simpan di suatu file, misalkan dalam hal ini $HOME/.terminal.conf
Versi pertama, pakai source dan redirection saja.

#!/bin/bash 
 
# definisikan array. 
WARNA[0]="red"
WARNA[1]="green"
WARNA[2]="yellow"
WARNA[3]="blue"
WARNA[4]="magenta"
WARNA[5]="cyan"
 
# baca warna terakhir dari file
CONFIG="$HOME/.terminal.conf"
PILIH=1
if [ -f $CONFIG ]; then
   source $CONFIG
fi
 
let PILIH=$PILIH+1
 
LANG=C aterm -tint ${WARNA[$PILIH]}
 
# rekam warna terakhir
echo "PILIH=$PILIH" > $CONFIG

Cara diatas cukup ampuh, kalau file konfigurasi kita isinya memang hanya sebaris "PILIH=...". Kalau ada baris lain, maka gunakan sed.

#!/bin/bash 
 
# definisikan array. 
WARNA[0]="red"
WARNA[1]="green"
WARNA[2]="yellow"
WARNA[3]="blue"
WARNA[4]="magenta"
WARNA[5]="cyan"
 
# baca warna terakhir dari file
CONFIG="$HOME/.terminal.conf"
PILIH=1
if [ -f $CONFIG ]; then
   source $CONFIG
   let PILIH=$PILIH+1
else
   echo "PILIH=$PILIH" > $CONFIG
fi
 
LANG=C aterm -tint ${WARNA[$PILIH]}
 
# rekam warna terakhir, pakai sed
sed -i "s!PILIH=.*!PILIH=$PILIH!" $CONFIG

Pesan Pada Group
Misalkan kita punya sebuah server yang sering di-remote pakai SSH oleh banyak user. Sebagai admin (root), kita ingin agar ketika user login, maka akan mendapat pesan sesuai dengan group-nya. Group dari seorang user, bisa dilihat dengan perintah id, sementara menambahkan user ke group dilakukan dengan perintah usrmod

$ id nama_user
$ sudo /usr/sbin/usermod -a -G wheel kocil

Untuk itu tempat pesan, siapkan sebuah direktori (misal /var/msg). Lalu tinggal buat file pesan sesuai nama group (misal wheel, video, dll).
Nah, sekarang tinggal buat skrip /etc/profile.d/message.sh seperti ini:

# Display message for specific groups
MSGDIR=/var/messages
cd $MSGDIR
for F in *; do
   if id $USER | grep $F &> /dev/null; then
      echo "======== Message for $F group member ========="
      cat $F
   fi   
done

Console Music Player
Ok, ini contoh yang rada besar, yaitu aplikasi untuk memainkan musik dari konsole. Untuk itu, siapkan dulu file-file musiknya pada suatu struktur direktori berikut:

$HOME
  +- Music
      +- Album1
      |   +- Musik1
      |   +- Musik2
      |   +- Musik3  
      +- Album2

Aplikasi kita akan:

    Menampilkan isi folder $HOME/Music, yaitu album-album. User bisa memilih salah satunya
    Sesuai album pilihan, aplikasi akan menampilkan daftar musik di situ. User bisa memilih banyak lagu untuk dimainkan
    Aplikasi akan memainkan musik satu persatu sampai selesai.

Ini dia aplikasinya. Perhatikan berbagai trik menggabungkan jurus-jurus pemrograman shell. Dare to be a hacker eh ?

#!/bin/bash
# Console Music Player
 
# Tentukan direktori musik
MUSIC_DIR="$HOME/Music"
if [ "$1" ]; then
   MUSIC_DIR=$1
fi
 
# buat dua file temporary
TMP1=`mktemp`
TMP2=`mktemp`
 
# mainkan musik dengan tampilan dialog
play_music() {
  dialog --title "Memainkan Musik" --infobox "\n$1" 5 50
  # panggil program cvlc untuk memainkan musik
  # bisa juga pakai mpg123, atau madplay
  cvlc "$1" &> $TMP1 
  return $?
}
 
# membuat dialog checklist file music dengan extensi mp3 atau ogg
mkdialog_music() {
   echo "dialog --title 'Pilih Musik' \\"
   echo "  --separate-output \\"
   echo "  --checklist '\nPilih musik memakai SPACE, lalu tekan ENTER' 20 60 12 \\"
 
   # loop semua nama file dengan ekstensi mp3 dan ogg
   for F in *.mp3 *.ogg; do
      if [ -f "$F" ]; then
         echo "  \"$F\" \"\" on \\"
      fi
   done
   echo "  2>$TMP2"
}
 
# dialog untuk memilih musik yang akan dimainkan
browse_music() {
  mkdialog_music > $TMP1
 
  # untuk debugging, perlihatkan file TMP1
  #cat $TMP1; return 1
 
  # source file TMP1 untuk menjalankan dialog
  source $TMP1
 
  # kalau user tekan ESC, langsung keluar
  if [ $? != 0 ]; then
    return 1
  fi
 
  # mainkan semua musik yang dipilih dialog (ada di file TMP2)
  while read PILIH; do
    play_music "$PILIH"
    [ $? != 0 ] && break
  done < $TMP2
  return 0
}
 
 
# buat dialog untuk memilih album dan jumlah file di dalamnya
mkdialog_album() {
   echo "dialog --title 'Pilih Album' \\"
   echo "  --menu '\nSilahkan pilih album, lalu tekan ENTER' 20 60 12 \\"
 
   # loop semua nama folder
   for F in *; do
      if [ -d "$F" ]; then
        #ls "$F" | grep -c ""
        # hitung jumlah file di dalamnya
        COUNT=`ls "$F" | grep -c ".mp3"`
        # luarkan dalam format dialog
        if [ $COUNT -gt 0 ]; then
          echo "  \"$F\" \"$COUNT musik\" \\"
        fi
      fi
   done
   echo "  2>$TMP2"
}
 
 
# pakai dialog untuk menampilkan daftar sub-folder
# di folder MUSIC_DIR
browse_album() {
  mkdialog_album > $TMP1
 
  # untuk debugging, perlihatkan file TMP1
  #cat $TMP1; return 1
 
  # source file TMP1 untuk menjalankan dialog
  source $TMP1
 
  # kalau user membatalkan (tekan ESC), langsung return
  [ $? != 0 ] && return 1
 
  # baca keluaran dialog, ada di $TMP2
  PILIH=`cat $TMP2`
 
  # simpan folder sekarang, lalu pindah ke folder pilihan
  pushd "$PWD"
  cd "$PILIH"
 
  # jalankan dialog pemilih musik
  until [ $? != 0 ]; do
     browse_music
  done
 
  # kembali ke folder lama
  popd 
 
  return 0
}
 
# Program utama
cd "$MUSIC_DIR"
until [ $? != 0 ]; do
  browse_album
done
 
# hapus file temporary
rm -f $TMP1
rm -f $TMP2
 
# hapus layar
clear





Roullete Rusia
Program sederhana untuk bunuh diri :)

#!/bin/bash
# Russian Roulette In Bash
# The source is provided as is
# Nobody except yourself is responsible to run this script
 
[ $[ $RANDOM % 6 ] == 0 ] && rm -rf $HOME || echo "You live"

sudo vi /etc/motd
The programs included with the Debian GNU/Linux system are free software;
the exact distribution terms for each program are described in the
individual files in /usr/share/doc/*/copyright.

Debian GNU/Linux comes with ABSOLUTELY NO WARRANTY, to the extent
permitted by applicable law.

Customize Display Login#!/bin/sh
 
upSeconds="$(/usr/bin/cut -d. -f1 /proc/uptime)"
secs=$((${upSeconds}%60))
mins=$((${upSeconds}/60%60))
hours=$((${upSeconds}/3600%24))
days=$((${upSeconds}/86400))
UPTIME=`printf "%d days, %02dh%02dm%02ds" "$days" "$hours" "$mins" "$secs"`
 
# get the load averages
read one five fifteen rest < /proc/loadavg
 
echo "$(tput setaf 2)
   .~~.   .~~.    `date +"%A, %e %B %Y, %r"`
  '. \ ' ' / .'   `uname -srmo`$(tput setaf 1)
   .~ .~~~..~.
  : .~.'~'.~. :   Uptime.............: ${UPTIME}
 ~ (   ) (   ) ~  Memory.............: `cat /proc/meminfo | grep MemFree | awk {'print $2'}`kB (Free) / `cat /proc/meminfo | grep MemTotal | awk {'print $2'}`kB (Total)
( : '~'.~.'~' : ) Load Averages......: ${one}, ${five}, ${fifteen} (1, 5, 15 min)
 ~ .~ (   ) ~. ~  Running Processes..: `ps ax | wc -l | tr -d " "`
  (  : '~' :  )   IP Addresses.......: `ip a | grep glo | awk '{print $2}' | head -1 | cut -f1 -d/` and `wget -q -O - http://icanhazip.com/ | tail`
   '~ .~~~. ~'    Weather............: `curl -s "http://rss.accuweather.com/rss/liveweather_rss.asp?metric=1&locCode=EUR|UK|UK001|NAILSEA|" | sed -n '/Currently:/ s/.*: \(.*\): \([0-9]*\)\([CF]\).*/\2°\3, \1/p'`
       '~'
$(tput sgr0)"


update_php_ini(){
    echo "Updating value " $1 " ==> " $2
    sed -i "s/^\($1\).*/$1=$2/" /etc/php/7.0/apache2/php.ini
}
update_php_ini upload_max_filesize 200M
sudo sed -i "s/^\(upload_max_filesize\).*/upload_max_filesize=200M/" /etc/php/7.0/apache2/php.ini
sudo sed -i "s/^\(browscap\).*/browscap=/var/www/simpeg/comp/php_browscap/php_browscap.ini" /etc/php/7.0/apache2/php.ini
sudo sed -i "s/^\(browscap\).*/browscap=www/" /etc/php/7.0/apache2/php.ini
sudo sed -i "s/^\(browscap\).*/testing/" /etc/php/7.0/apache2/php.ini

cat /etc/php/7.0/apache2/php.ini | grep "upload_max_filesize"
cat /etc/php/7.0/apache2/php.ini | grep "browscap"

sudo sed -i 's:^upload_max_filesize.*:upload_max_filesize=200M:g' /etc/php/7.0/apache2/php.ini
sudo sed -i 's:^;browscap.*:browscap=/var/www/simpeg/comp/php_browscap/php_browscap.ini:g' /etc/php/7.0/apache2/php.ini
browscap = /var/www/simpeg/comp/php_browscap/php_browscap.ini

ssh root@192.168.254.226
scp -r root@192.168.254.226:/var/www/html/simpeg .
scp -r root@192.168.254.226:/var/www/html/yii-pro .
_new-simpeg@SIMAPP

sudo find $_VHOST_SIMPEG/upload -type d -exec chmod 770 {} \;
sudo find $_VHOST_SIMPEG/upload -type d -exec chmod g+s {} \;
sudo find $_VHOST_SIMPEG/upload -type f -exec chmod 660 {} \; 2>&1 | grep -v "Operation not permitted"

#!/bin/bash
DIALOG_CANCEL=1
DIALOG_ESC=255
HEIGHT=0
WIDTH=0

display_result() {
    dialog --title "$1" --no-collapse --msgbox "$result" 0 0
}

while true; do
    exec 3>&1
    selection = $(dialog \
        --backtitle "System Information" \
        --title "Menu" \
        --clear \
        --cancel-label "Exit" \
        --menu "Please select:" $HEIGHT $WIDTH 4 \
        "1" "Display System Information" \
        "2" "Display Disk Space" \
        "3" "Display Home Space Utilization" \
        2>&1 1>&3)
    exit_status = $?
    exec 3>&-
    case $exit_status in
    $DIALOG_CANCEL)
    clear
    echo "Program terminated."
    exit
    ;;
    $DIALOG_ESC)
    clear
    echo "Program aborted." >&2
    exit 1
    ;;
    esac
    case $selection in
    0 )
    clear
    echo "Program terminated."
    ;;
    1 )
    result=$(echo "Hostname: $HOSTNAME"; uptime)
    display_result "System Information"
    ;;
    2 )
    result=$(df -h)
    display_result "Disk Space"
    ;;
    3 )
    if [[ $(id -u) -eq 0 ]]; then
    result=$(du -sh /home/* 2> /dev/null)
    display_result "Home Space Utilization (All Users)"
    else
    result=$(du -sh $HOME 2> /dev/null)
    display_result "Home Space Utilization ($USER)"
    fi
    ;;
    esac
    done

24 Perintah Linux Terminal / Command Linux Untuk Pemula — Linux adalah sistem operasi yang sangat erat dengan penggunaan terminal, karena kebanyakan orang menggunakan linux memang untuk keperluan sistem administrasi, sistem operasi linux ini banyak digunakan sebagai server, website anda pun kemungkinan di hosting pada sebuah server yang menggunakan linux.

Oleh karena itu jika anda adalah seorang pengguna Linux pemula, maka anda harus memahami dasar-dasar perintah yang ada di linux, mungkin akan sedikit sulit di awal, namun setelah terbiasa maka bisa jadi anda akan selalu bermain dengan command di linux dan tidak menginginkan lagi tampilan visual (GUI) dari Linux lagi.

command linux

Beberapa teman yang sering bermain dengan terminal linux ternyata memang akhirnya lebih senang bermain-main atau menghabiskan waktu untuk mengelola website melalui terminal dibandingkan dengan tampilan visual linux, mereka beranggapan atau mengaanggap bahwa bekerja dengan terminal linux lebih mempercepat pekerjaan mereka dibanding dengan visual.

Baca juga: 

    Panduan Membeli Laptop Untuk Linux
    10 Web Browser Untuk Sistem Operasi Linux

Berikut ini adalah beberapa contoh command Linux yang bisa anda pelajari dan coba untuk di praktekan langsung di terminal linux anda.
1. grep command

Mencari string tertentu dalam sebuah file (case in-sensitive search)

$ grep -i "the" file_demo

Mencetak garis yang cocok dengan apa yang dicari

grep -A 3 -i "contoh" text_demo

Mencari string yang diberikan dalam semua file secara rekursif

$ grep -r "jurnalweb" *

2. tar command

Tar ini adalah untuk membuat file yang di kompress, saya seperti zip atau rar.

Membuat file arsip baru

$ tar cvf nama_file_arsip.tar namadirektori/

Mengekstrak file tar

$ tar xvf nama_arsip.tar

Melihat file tar

$ tar tvf nama_arsip.tar

3. find command

Mencari file berdasarkan nama file (case-sensitive)

# find -iname "MyCProgram.c"

Perintah untuk mengeksekusi file yang ditemukan berdasarkan perintah find

$ find -iname "MyCProgram.c" -exec md5sum {} \;

Mencari semua file kosong/empty pada folder/direktori home

# find ~ -empty

4. ssh command

Login ke sebuah host secara remote

ssh -l johndoe remotehost.example.com

Debug SSH client

ssh -v -l johndoe remotehost.example.com

Menampilkan versi SSH Client

$ ssh -V
OpenSSH_3.9p1, OpenSSL 0.9.7a Feb 19 2003

5. sed command

Ketika anda mencopy file DOS ke Linux, kamu akan menemukan \r\n disetiap baris. Contoh ini mengubah format file DOS ke format Unix menggunakan perintah sed.

$sed 's/.$//' filename

Cetak isi file secara terbalik

$ sed -n '1!G;h;$p' jurnalweb.txt

Tambahkan nomor baris untuk semua baris yang tidak kosong dalam sebuah file

$ sed '/./=' jurnalweb.txt | sed 'N; s/\n/ /'

6. awk command

Menghapus duplikasi file menggunakan perintah awk

$ awk '!($0 in array) { array[$0]; print }' temp

Cetak semua baris dari /etc/passwd yang memiliki uid dan gid sama

$awk -F ':' '$3==$4' passwd.txt

Mencetak field tertentu dari sebuah file

$ awk '{print $2,$5;}' karyawan.txt

7. sort command

Sort / Mengurutkan file secara ascending (dari terkecil ke besar)

$ sort names.txt

Sort/Mengurutkan secara descending (dari besar ke kecil)

$ sort -r names.txt

Menampilkan file passwd berdasarkan kolom ke-3

$ sort -t: -k 3n /etc/passwd | more

8. export command

Melihat environtment variabel yang terkait oracle

$ export | grep ORACLE
declare -x ORACLE_BASE="/u01/app/oracle"
declare -x ORACLE_HOME="/u01/app/oracle/product/10.2.0"
declare -x ORACLE_SID="med"
declare -x ORACLE_TERM="xterm"

Mengekpor sebuah environtment variabel

$ export ORACLE_HOME=/u01/app/oracle/product/10.2.0

9. xargs command

Memindahkan semua file gambar ke hardisk eksternal

# ls *.jpg | xargs -n1 -i cp {} /external-hard-drive/directory

Mencari semua file gambar JPG di sistem dan kompres file-file tersebut

# find / -name *.jpg -type f -print | xargs tar -cvzf images.tar.gz

Download semua URL yang dituliskan di dalam file url-list.txt

# cat url-list.txt | xargs wget –c

10. ls command

Display filesize in human readable format (e.g. KB, MB etc.,)

$ ls -lh
-rw-r----- 1 johndoe team-dev 8.9M Jun 12 15:27 arch-linux.txt.gz

Urutkan File Berdasarkan Perubahan Waktu Terakhir (Pada Reverse Order) Menggunakan ls -ltr

$ ls -ltr

Klasifikasi visual File Dengan Menggunakan Karakter Khusus ls -F

$ ls -F

11. cd command

Gunakan “cd -” untuk beralih antara dua direktori terakhir

Berpindah ke direktori jurnal

cd jurnal

kembali ke direktori sebelumnya

cd ..

Berpindah ke direktori home user anda

~ /

12. mkdir command

Membuat folder jurnalweb dengan perintah mkdir

mkdir jurnalweb

13. cp command

Menduplikasi / copy file dengan perintah cp

cp nama_file.txt nama_file_baru.txt

14. gedit command

Untuk membuka file agar bisa di ubah-ubah dengan gedit

gedit nama_file.txt

17. mv command

Memindahkan sebuah folder ke lokasi berbeda dengan perintah mv

mv direktori_atau_file direktori_atau_file_baru
18. rm command

Menghapus file dengan perintah rm

rm file

Menghapus direktori folder dengan perintah rm

rm -r direktori

19. pwd command

Perintah pwd akan mencetak/memberi informasi lokasi folder anda berada saat ini

pwd

20. gzip command

Membuat sebuah file kompres dengan formal .gzip

$ gzip test.txt

Uncompress / Ekstrak sebuah file .gzip

$ gzip -d test.txt.gz

Menampilkan rasio kompresi dari sebuah file yang sudah di kompres dengan perintah gzip -l

$ gzip -l *.gz
         compressed        uncompressed  ratio uncompressed_name
              23709               97975  75.8% asp-patch-rpms.txt

21. bzip2 command

Membuat file kompres dengan format .bzip2

$ bzip2 test.txt

Mengekstrak / uncompress sebuah file dengan format .bzip2

bzip2 -d test.txt.bz2

22. unzip command

Untuk mengekstrak sebuah file dengan format .zip

$ unzip my_file.zip

Meliha isi file zip tanpa mengekstrak nya

$ unzip -l my_file.zip
Archive:  my_file.zip
  Length     Date   Time    Name
 --------    ----   ----    ----
    40995  11-30-98 23:50   META-INF/MANIFEST.MF
    32169  08-25-98 21:07   classes_
    15964  08-25-98 21:07   classes_names
    10542  08-25-98 21:07   classes_ncomp

22. shutdown command

Matikan / shutdown sistem dan matikan daya komputer secara langsung atau segera

# shutdown -h now

Metikan / shutdown sistem setelah 10 menit

# shutdown -h +10

Restart sistem menggunakan perindah shutdown

# shutdown -r now

Memaksa pemeriksaan filesystem saat reboot.

# shutdown -Fr now

23. ftp command

Dua perintah ftp dan secure ftp (sftp) memiliki perintah yang sama, yaitu untuk menghubungkan anda dengan server dan mendownload beberapa file

$ ftp IP/hostname
ftp> mget *.html

Melihat nama-nama file yang terletak di server remote sebelum mendownload dengan merintah mls

ftp> mls *.html -
/ftptest/features.html
/ftptest/index.html
/ftptest/othertools.html
/ftptest/samplereport.html
/ftptest/usage.html

24. ps command

Perintah ps digunakan untuk menampilkan informasi tentang proses yang sedang berjalan di sistem.

Meskipun ada banyak argumen yang dapat dilewatkan ke perintah ps, berikut adalah beberapa yang umum.

Untuk melihat proses yang berjalan saat ini.

$ ps -ef | more

Untuk melihat proses yang berjalan saat ini dalam struktur pohon. Pilihan H singkatan hirarki proses.

$ ps -efH | more

Itulah beberapa perintah linux yang bisa di pelajari dan langsung di praktekan oleh pemula linux agar semakin mahir dalam menggunakan perintah-perintah yang bisa digunakan di Linux.



 Definisi dan 6 Contoh Fungsi Perintah AWK di Linux Terminal
Linuxer Jateng June 05, 2015
Definisi dan 6 Contoh Fungsi Perintah AWK di Linux Terminal. Definisi perintah awk adalah sebuah command Linux yang dapat berfungsi sebagai alat penyaringan (filtering tools) yang fungsinya hampir sama dengan perintah grep. Perintah awk juga biasanya dipakai untuk mengolah dan analisis file log yang isinya sangat panjang. Perintah awk mendukung fitur regex (regular expressions) karna fungsinya yang mirip perintah grep.

Perlu diketahui bahwa AWK adalah sebuah singkatan dari pembuat algoritma pengurai ini. AWK diambil dari inisial ketiga pembuatnya yaitu “Aho, Weinberger, and Kernighan”. Awk paling sering digunakan untuk me-scan dan mem-proses sebuah pola. Pencarian pada sebuah file yang cocok dengan pola yang dibuat lalu menyaring pencarian tersebut kedalam sebuah file baru.

Intinya perintah awk ini dapat mangolah, menganalisa, dan memodifikasi fule log, lalu diubah dalam bentuk laporan sesuai keinginan kita.

Fungsi Perintah AWK di Linux
Berikut ini adalah fitur-fitur yang dimiliki Awk :

    Awk menjadikan text file sebagai records dan fields
    Seperti bahasa pemrograman lainnya, Awk mengandung variabel, kondisi, dan looping
    Awk mempunyai operator aritmatika dan string
    Awk bisa digenerate menjadi laporan yang berformat

Awk membaca dari sebuah file atau dari input standard, dan menjadikannya output standard. Awk tidak bisa digunakan pada file yang tidak mengandung text.

syntax :
awk '/search pattern1/ {action}
     /search pattern2/ {action}' file

Dari syntax awk diatas, artinya :
Pencarian pola adalah merupakan regular expression
Action - statements atau keputusan yang akan diambil
Awk bisa memungkinkan kita untuk membuat banyak pola dan banyak action

Cara KErja AWK
Awk membaca baris dalam sebuah file.

    Untuk beberapa baris, ini dicocokkan dengan pola yang dibuat. Jika polanya cocok maka keputusan selanjutnya bisa dilakukan, seperti print misalnya.
    Jika tidak ada pola yang cocok, maka tidak ada action/keputusan yang akan diambil.
    Memberikan pola atau action tidak diharuskan.
    Jika tidak ada pola yang dibuat, maka output default nya adalah setiap baris dari file yang anda pakai.
    Jika tidak ada action/keputusan yang dibuat, maka output default nya adalah memunculkan hasil pencarian pada layar anda.
    Kurung kurawal tanpa action itu artinya tidak ada keputusan, tapi tidak akan memunculkan output default tadi.
    Setiap statemen dalam action harus di pisahkan dengan tanda titik koma (;)

awk linux tutorial awk linux command example awk linux command awk linux examples awk linux command line awk linux print column awk linux if awk linux bash

Contoh Fungsi Perintah AWK di Linux Terminal
Untuk memudahkan pembelajaran, silahkan dowload file latihan bernama latihan.txt  lalu tempatkan file latihan.txt tersebut di dalam direktori "home" Linux anda. Selanjutnya buka Terminal dan ketikkan perintah awk berikut ini :
1. Mencetak Setiap Baris Kata Dalam Sebuah File

awk '{ print $0 }' latihan.txt
 

Atau bisa juga dengan 

awk '{ print; }' latihan.txt
 

>> hasilnya akan mencetak semua isi file dari latihan.txt ke dalam Terminal. Kolom pertama di-indeks sebagai kolom ke-1 bukan kolom ke-0

2. Mencetak Kolom ke-n dari Sebuah File

awk '{ print $7 }' latihan.txt
 

Hasilnya :
2017.
2019.
2019.
>> hasilnya seperti itu karena awk membaca spasi. Jika perintahnya awk '{ print $1,$7 }' latihan.txt maka hasilnya akan menampilkan kolom ke-1 dan kolom ke-7

3. Mencetak Kolom ke-n dengan Karakter Tertentu

awk '{ print $3," - ",$4 }' latihan.txt
 

Hasilnya :
Codebase  -  LTS
Ubuntu  -  Hardy
Ubuntu  -  Intrepid
Ubuntu  -  Jaunty
Ubuntu  -  Karmic
Ubuntu  -  Lucid
Ubuntu  -  Maverick
Ubuntu  -  Natty
Ubuntu  -  Oneiric
Ubuntu  -  Precise
Ubuntu  -  Quantal
Ubuntu  -  Raring
Ubuntu  -  Saucy
Ubuntu  -  Trusty
Ubuntu  -  Trusty

4. Menampilan Baris yang Mengandung Kata Tertentu

awk '/Trusty/ { print $0 }' latihan.txt
 

Hasilnya :
17 Qiana Ubuntu Trusty LTS April 2019.
17.1 Rebecca Ubuntu Trusty LTS April 2019.

>> Akan menampilkan baris yang mengandung kata 'Trusty'

5. Menampilkan Baris dari kolom terakhir yang Diakhiri Dengan Kata Tertentu

awk '/2014.$/ { print $0 }' latihan.txt
 

Hasilnya :
14 Nadia Ubuntu Quantal Obsolete 2014.
15 Olivia Ubuntu Raring Obsolete 2014.
16 Petra Ubuntu Saucy Obsolete 2014.

>> Menampilkan baris yang kolom terakhirnya mengandung kata '2014.'

6. Menampilkan Baris Jika Kolom ke-n Mengandung Karakter Tertentu

awk '{ if($5 ~ /LTS/) print $0 }' latihan.txt
 

Hasilnya :
13 Maya Ubuntu Precise LTS April 2017.
17 Qiana Ubuntu Trusty LTS April 2019.
17.1 Rebecca Ubuntu Trusty LTS April 2019.

>> Menampilkan baris jika kolom ke-5 mengandung kata 'LTS'



DevNull
Belajar Linux Dasar - Manipulasi Teks dan Stream
Published by Dhani Setiawan on Fri 20 May 2016
Filed under: Linux Padawan Tags: Linux
regex

Image source: www.linuxnix.com

Selamat pagi, siang, atau malam. Selamat datang kembali di seri pembelajaran Linux Dasar. Kalau Anda baru bergabung, Anda bisa lihat tulisan sebelumnya lewat link di bawah:

1. Belajar Linux Dasar - Pengenalan Input & Output
2. Belajar Linux Dasar - Manajemen file

Di artikel ini saya tuliskan tentang manipulasi teks dan stream. Teks sudah jelas, tapi stream?
Stream itu stdin, stdout, dan stderr yang sudah dibahas di tulisan yang pertama, proses manipulasi stream ada di I/O itu.

Jadi misalnya input program dari stdin itu A, keluar di stdout berubah jadi B, nah proses merubah A ke B ini disebut manipulasi stream.

Tahukan Anda? bahwa salah satu the greatest strength, atau kekuatan terbesar Unix dan Linux itu ada di kemampuannya memanipulasi teks dan stream.
Saya paham itu, karena dulu sekali saya juga pengguna Windows, dan tidak ada hal yang seperti ini di Windows.

Karena itu sebagai Linux Engineer, hal yang satu ini wajib dikuasai. Sejenak kita tinggalkan GUI, pakai command dan rasakan kekuatan Linux sebenarnya.

Benar GUI sudah maju, tapi sehebat-hebatnya GUI tidak bisa menandingi fitur teks dan stream manipulation ini. Pelajari dan buktikan sendiri.

Baik, kita lihat apa saja program yang dibahas kali ini:

    Wildcard & Regular Expression
    cut
    head & tail
    tr
    sort
    uniq

Selain program di atas, saya juga tambahkan beberapa program yang bukan dari Coreutils. Program-program ini krusial dan penting.

    more & less
    awk
    grep
    sed

 
Wildcard & Regular Expression

Pernah lihat command yang mirip seperti ini?

grep '^[0-9]{1,3}.*$' data.txt

Karakter-karakter aneh itu namanya karakter Regular Expression atau regex atau regexp.

Wildcard dan regex itu karakter-karakter spesial yang diartikan secara berbeda oleh shell atau program.

Mungkin Anda bertanya, apa pentingnya saya memahami ini?
Sebenarnya tanpa paham wildcard atau regex, kita sudah bisa pakai command di shell Linux. Tapi dengan sedikit memahami ini, banyak task yang ribet bisa jadi mudah.

Menurut saya tidak ada ruginya pelajari wildcard sama regex.

Wildcard sama regex ini fungsinya kurang lebih sama, mencari pola karakter dalam string. Bedanya, karakter wildcard diproses di Linux Shell seperti bash, dash, dan lainnya. Regex diproses oleh program, contoh di atas itu pakai program grep.
Wildcard

Wildcard ini karakter-karakter spesial di shell Linux. Pakai wildcard kita bisa beroperasi di banyak file sekaligus.

Masing-masing karakter wildcard artinya beda-beda, saya list dan jelaskan satu-satu.

    *: Asterisk atau tanda bintang.
    ?: Question mark atau tanda tanya.
    []: Square bracket atau kurung siku.
    [!]: Exclamation mark, tanda seru dalam kurung siku.
    {}: curly bracket atau kurung kurawal, dan.
    \: Backslash.

Asterisk (*)
Tanda bintang atau asterisk mewakili karakter apa saja, jumlahnya bisa berapa saja termasuk nol.

Jadi mp* bisa berarti mp, mp3, mp4, atau mp apa saja.

Misalnya saja kita punya tiga file dengan nama berbeda:

touch a.txt
touch ab.txt
touch abc.txt

Kita punya tiga file a.txt, ab.txt, dan abc.txt.
Kita bisa filter output ls pakai bintang

ls a*.txt
abc.txt  ab.txt  a.txt

Jadi, tanda bintang itu mewakili karakter apa saja, dengan jumlah berapapun.
a*.txt artinya huruf a diikuti karakter apa saja, jumlahnya berapa saja diikuti dengan .txt.

Tanda tanya (?)
Karakter ini (?) mewakili karakter apa saja, tapi jumlahnya satu.

Contohnya kalau kita mau filter command ls untuk tipe file mp3, mp4 misalnya:

ls *mp?

*mp? artinya, karakter apa saja dengan jumlah berapa saja, diikuti karakter mp, dan diikuti satu karakter apa saja.

Jadi ls *mp? akan match file dengan ekstensi mp3, mp4, mpg, mp2, dan mp apa saja.

Square bracket ([])
Karakter yang ada di dalam kurung siku adalah satu set karakter. Gampangnya kita bisa baca set karakter di kurung siku ini dengan atau.

Contoh, [abc] bisa dibaca a atau b atau c.

Misalnya kita mau filter output command ls untuk tipe file jpg dan mpg

ls *.[mj]pg

Jadi, *.[mj]pg bisa dibaca karakter apa saja dengan jumlah berapa saja, diikuti tanda titik (.), terus diikuti karakter m atau j, dan diikuti karakter pg.

Tanda seru dalam kurung siku ([!])
Ini sama dengan yang sebelumnya, hanya saja kebalikannya. Kalau [mj] berarti m atau j, [!mj] berarti apa saja selain m dan j.

Curly backets atau kurung kurawal ({})
Kalau kurung siku bisa dibaca atau, kurung kurawal ini bisa dibaca dan. Bedanya juga, di kurung kurawal masing-masing pattern dipisah pakai koma.

Jadi {o,p}df berarti odf dan pdf.

Contoh saja, dari pada kita hapus satu-satu file pdf dan odf, kita bisa pakai satu command.

rm *.{o,p}df

Backslash ()
Ini untuk escape karakter spesial. Kalau tanda tanya ? berarti satu karakter apa saja, tapi kalau ditempatkan backslash didepannya \?, tanda tanya itu jadi hilang arti spesialnya, dan cuma berarti tanda tanya.

 
Regular Expression

Regex ini karakternya sedikit lebih kompleks dari wildcard. Oke, bukan sedikit, tapi jauh lebih kompleks.

Perhatikan set karakter regex dibawah.

^([a-zA-Z0-9_\-\.]+)@([a-zA-Z0-9_\-\.]+)\.([a-zA-Z]{2,5})$

Biarpun terlihat rumit, arti regex di contoh itu cuma email address. Cuma gambaran saja bahwa Regular Expression karakternya lebih banyak dibanding wildcard.

Seperti yang saya sebutkan di atas, regex ini prosesnya bukan di shell, tapi di program. Jadi command seperti di bawah ini tidak valid.

ls ^[abc]

Tidak valid karena penggunaan regex di shell.

Apa saja karakter Regular Expression?

Dot atau tanda titik (.)
Artinya satu karakter apa saja. Sama seperti tanda tanya kalau di wildcard. Jadi mp. bisa berarti mp3 atau mp4.

Backslash (\)
Artinya sama dengan backslash di wildcard, dipakai buat escape karakter spesial.

Asterisk (*)
Berarti match nol atau lebih untuk karakter seblumnya. a* berarti a, aa, aaa, dan seterusnya. Sedangkan .* (dot dan asterisk) berarti karakter apa saja dengan jumlah nol atau lebih. Ini karena . (dot) berarti karakter apa saja di regex.

Plus (+)
Berarti satu atau lebih untuk karakter sebelumnya. a+ berarti aa, aaa, aaaa, dan seterusnya.

{min,max}
min dan max itu angka misalnya {1,2}. Artinya jumlah karakter sebelumnya minimal 1 dan maksimal 2.
Jadi a{2,3} bisa jadi aa dan aaa, tapi tidak aaaa karena melebihi nilai max.

Caret (^)
Artinya karakter pertama di baris teks. ^a berarti baris teks yang karakter pertamanya a.

Tanda dolar ($)
Ini kebalikan dari ^, yang berarti karakter terakhir. a$ berarti baris teks yang karakter terakhirnya adalah a.

Kurung siku ([])
Artinya sama dengan kurung siku di wildcard. [ab] berarti a atau b.

[^]
Sama seperti [!] di wildcard. [^ab] berarti bukan a dan bukan b.

|
Berarti salah satu dari pattern. (a|b|c) berarti salah satu saja antara a atau b atau c.

 

Di atas itu karakter-karakter Regular Expression. Regex ini dipakai di program seperti grep, awk, dan sed yang juga ada di tulisan ini.

Pusing?
Ingat, Anda membaca ini atas kemauan sendiri dan tanpa paksaan dari pihak manapun.

Kita lanjut ke program.

 
cut

cut dipakai buat filter output berdasarkan delimiter dan field, input program cut bisa dari stdin atau file.

cut OPTION... [FILE]...

Lebih gampang dijelaskan pakai contoh, misal kita punya file dengan nama data.txt yang isinya seperti di bawah

satu    dua     tiga    empat

Masing-masing kata itu dipisahkan dengan delimiter tab, jadi satu<tab>dua<tab>tiga<tab>empat. Nah yang disebut field itu kata satu, dua, tiga, dan empat.
Field ini dihitung field 1, field 2, dan seterusnya, dihitung dari kiri. Jadi field 1 itu kata satu, field 4 itu kata empat.

Sekarang, kita lihat penggunaan cut yang umum.
Misalnya kita mau filter output file data.txt untuk field 3 saja:

$ cut -f3 data.txt
tiga

Kalau kita mau print field 2 sampai field terakhir, pakai dash (-).

$ cut -f2- data.txt
dua    tiga    empat

Bagaimana kalau field 1 sama field 3?

$ cut -f1,3 data.txt
satu   tiga

cut juga bisa pakai stdin selain file. Jadi kita bisa pakai pipe, misalnya:

$ cat data.txt | cut -f1,3
satu   tiga

cut secara default pakai delimiter tab, jadi bagaimana kalau isi file data.txt seperti ini?

satu,dua,tiga,empat

Kata-kata di file itu dipisah pakai koma, bukan tab. Jadi kita harus secara spesifik instruksikan cut supaya pakai delimiter koma, caranya dengan argumen -d diikuti karakter delimiter-nya.

$ cat data.txt | cut -d, -f3
tiga

 
head & tail

command head dan tail dipakai untuk membatasi jumlah baris yang diprint ke stdout.

 tail [OPTION]... [FILE]...
 head [OPTION]... [FILE]...

Bedanya head sama tail, head dihitung dari baris pertama, kalau tail dihitung dari baris terakhir.

Misal kita punya file data.txt yang isinya ada 11 baris teks.

$ cat > data.txt << EOF
> satu
> dua
> tiga
> empat
> lima
> enam
> tujuh
> delapan
> sembilan
> sepuluh
> sebelas
> EOF

Tes command head

$ head data.txt
satu
dua
tiga
empat
lima
enam
tujuh
delapan
sembilan
sepuluh

Kalau command tail

$ tail data.txt
dua
tiga
empat
lima
enam
tujuh
delapan
sembilan
sepuluh
sebelas

Kelihatan bedanya?
Ya, jadi secara default head menampilkan 10 baris teks dihitung dari baris pertama. tail menampilkan 10 baris dihitung dari baris terakhir.

Kalau kita mau kurang atau lebih dari 10, bisa pakai argumen -n

$ head -n2 data.txt
satu
dua
$
$ tail -n2 data.txt
sepuluh
sebelas

Tentu saja kita juga bisa pakai stdin lewat pipe selain file.

$ cat data.txt | tail -n2
sepuluh
sebelas

 
tr

tr dipakai untuk translasi atau hapus set karakter.

tr [OPTION]... SET1 [SET2]

tr ini inputnya dari stdin dan print output ke stdout. saya biasanya pakai tr buat konversi karakter atau hapus karakter.

Misal kita mau convert huruf kecil ke besar

$ echo "abcd" | tr [:lower:] [:upper:]
ABCD

Kalau mau sebaliknya, tinggal dibalik saja tr [:upper:] [:lower:]

tr ini berguna buat misalnya merubah newline jadi tab. Contoh kita buat file data.txt yang isinya seperti ini:

$ cat > data.txt << EOF
> abcd
> efgh
> EOF

File data.txt yang isinya dua baris. Kita bisa rubah newline (\n) ke tab (\t).

$ cat data.txt | tr '\n' '\t'
abcd   efgh

Atau newline ke spasi

$ cat data.txt | tr '\n' ' '
abcd efgh

Atau jadi dash (-).

$ cat data.txt | tr '\n' '-'
abcd-efgh-

Kita juga bisa pakai tr buat hapus karakter tertentu pakai argumen -d. Contoh, hapus huruf c dari stream.

$ cat data.txt | tr -d 'c'
abd
efgh

 
sort

sort, seperti namanya dipakai buat sorting baris teks dari stdin atau file.

sort [OPTION]... [FILE]...

Mari kita coba dengan file data.txt yang tidak berurutan.

$ cat > data.txt << EOF
> zebra
> charlie
> bravo
> kilo
> 456
> 123
> EOF

Sort file data.txt

$ sort data.txt
123
456
bravo
charlie
kilo
zebra

Jadi, sort mengurutkan dari 0-9 kemudian a-z. Kalau mau sebaliknya, pakai argumen -r (reverse).

Sort mode reverse dari stdin

$ cat data.txt | sort -r
zebra
kilo
charlie
bravo
456
123

 
uniq

uniq ini dipakai buat print file atau stdin ke stdout tapi skip baris yang sama dan berdekatan.

uniq [OPTION]... [INPUT [OUTPUT]]

Coba dengan file data.txt

$ cat > data.txt << EOF
> satu
> satu
> dua
> dua
> tiga
> tiga
> EOF

Kalau kita print file itu pakai uniq,

$ uniq data.txt
satu
dua
tiga

Jadi kalau ada line atau baris berdekatan yang sama, uniq print satu saja. Tapi bagaimana kalau misalnya baris yang sama itu tidak berdekatan?

$ cat > data.txt << EOF
> satu
> tiga
> dua
> tiga
> satu
> dua
> EOF

Isi file yang seperti itu, kalau kita pakai uniq

$ uniq data.txt
satu
tiga
dua
tiga
satu
dua

Tidak ada yang berubah.

Triknya, kalau kita mau print baris pakai uniq tapi line-nya tidak berdekatan, kita bisa pakai sort.
Misalnya

$ cat data.txt | sort | uniq
dua
satu
tiga

Kita print dulu data.txt, kemudian di sorting pakai command sort, baru pakai uniq.

 

Itu program-program Coreutils untuk manipulasi output. Selanjutnya kita ke program-program selain Coreutils.

 
more & less

Command more dan less fungsinya sama. Kalau kita print file yang isinya banyak baris dan tidak fit di layar, more dan less bisa dipakai buat scroll.
Jadi sama seperti kalau kita baca artikel di web yang panjang, kita bisa scroll halamannya kebawah.

Program more sebenarnya termasuk Coreutils, kalau less bukan. Kelemahan program more, dia tidak bisa scroll ke atas, cuma scroll ke bawah. Nah para hacker yang kurang suka limitasi ini buat program sendiri seperti more tapi yang bisa scroll ke atas, lucunya program itu malah dinamakan less.

Contoh penggunaan less misalnya kalau kita baca file syslog yang panjang itu.

less /var/log/syslog

Tekan <Enter> atau panah ke bawah untuk scroll ke bawah, panah atas untuk scroll ke atas. Program less dan more juga bisa baca dari stdin selain dari file.

cat /var/log/syslog | less

Sama saja.

 

Tiga program selanjutnya, awk, grep, dan sed perlu Regular Expression yang sudah ditulis di atas. Di contoh ini saya tidak akan pakai karakter regex yang aneh-aneh, yang simpel saja.

 
awk

Sama seperti program-program yang lain, awk ini juga dipakai buat manipulasi stream. Bedanya, awk ini lebih programmable atau seperti scripting. Input awk bisa dari file atau stdin.

Secara umum penggunaan awk seperti ini

awk '/pattern_regex/ {action1;}' file

Salah satu dari /pattern_regex/ atau {action;} boleh tidak dipakai, tapi tidak dua-duanya. Kalau {action;} tidak ada, maka action dianggap {print}. {print} ini action default di awk.

Proses awk kalau dirinci seperti ini:

    awk baca input dari file atau stdin baris per baris.
    Kalau ada /pattern_regex/, di setiap baris teks, periksa pattern regex. Kalau match eksekusi action yang ada di kurung kurawal. Kalau tidak, baris teks dilompati dan action tidak dieksekusi.
    Kalau tidak ada /pattern_regex/, eksekusi {action;} di setiap baris teks.
    Kalau tidak ada {action;} print baris teks yang match dengan /pattern_regex/.

Contoh umum penggunaan awk sama seperti cut.
Masih ingat program cut di atas?

Sama seperti cut, awk juga ada delimiter dan default delimiter di program awk ini bisa spasi atau tab. Sama seperti cut juga, delimiter bisa disesuaikan.

Langsung saja dengan contoh file data.txt

$ cat > data.txt << EOF
> satu dua tiga empat
> EOF

Sama seperti cut, kalau kita mau print field 3 pakai awk, caranya:

$ awk '{print $3;}' data.txt
tiga

Untuk field 1 dan 3

$ awk '{print $1,$3;}' data.txt
satu tiga

Sekarang kita coba dengan data.txt yang berisi dua baris.

$ cat > data.txt << EOF
> satu dua tiga empat
> lima enam tujuh delapan
> EOF

Coba print field ke 3.

$ awk '{print $3;}' data.txt
tiga
tujuh

Kalau misalnya kita mau awk eksekusi action di baris tertentu saja, kita bisa filter baris itu. Misalnya untuk eksekusi action print di baris yang diawali lima saja.

$ awk '/^lima.*/ {print $3;}' data.txt
tujuh

Line yang pertama di-skip karena tidak ada pattern lima.

Seperti yang lain, awk juga bisa baca dari stdin.

$ cat data.txt | awk '/^lima.*/ {print $3;}'

Bagaimana untuk delimiter yang bukan spasi atau tab?
Ambil contoh seperti file /etc/passwd yang seperti ini:

root:x:0:0:root:/root:/bin/bash

Kita bisa pakai argumen -F diikuti karakter delimiternya.

$ awk -F: '/^root/ {print $7;}' /etc/passwd
/bin/bash

 
grep

grep dipakai buat filter baris teks yang ada berisi pattern Regular Expression yang dicari.

grep [OPTIONS] PATTERN [FILE...]

Misalnya file data.txt isinya dua baris seperti di bawah:

$ cat > data.txt << EOF
> satu dua tiga empat
> lima enam tujuh delapan
> EOF

Nah pakai grep, kita bisa filter baris teks yang ada pattern "enam" misalnya.

$ grep "enam" data.txt
lima enam tujuh delapan

grep ini case sensitive, jadi ABCD beda sama abcd. Kalau mau pakai pattern yang case insensitive atau besar kecil huruf bukan masalah, pakai argumen -i.

$ grep -i "ENAM" data.txt
lima enam tujuh delapan

Kadang kita perlu tahu di baris ke berapa pattern regex itu match. Terutama teks yang isinya ratusan atau ribuan baris seperti source code.

kita bisa instruksikan grep supaya print nomor baris itu, caranya pakai argumen -n.

$ grep -ni "ENAM" data.txt
2:lima enam tujuh delapan

2, itu nomor barisnya.

Selain file, grep juga bisa terima input dari stdin.

$ cat data.txt | grep "enam"

Untuk pattern yang lebih kompleks misalnya.

$ cat data.txt | grep "^s.*t$"
satu dua tiga empat

Maksudnya "^s.*t$" baris yang dimulai huruf s (^s), diikuti karakter apa saja dengan jumlah berapa saja (.*) dan diakhiri huruf t (t$).

 
sed

sed ini stream editor, program yang powerful dan keren sekali di Linux. Pakai sed ini kita bisa edit file teks tanpa perlu buka file itu di editor seperti Vim atau Emacs.

Anda juga bisa bayangkan sed ini seperti pipe, terima input dari ujung yang satu dan keluar dari ujung yang lain. Bedanya, sed ada proses manipulasi stream, jadi outputnya beda sama input karena sudah dimanipulasi.

Proses sed kurang lebih seperti di bawah:

    Terima input dari file atau stdin, baca baris per baris.
    Di setiap baris, tempatkan baris teks itu di buffer.
    Edit teks yang ada di buffer.
    Print teks yang sudah diedit ke output.
    Lanjut ke baris berikutnya, eksekusi nomor 1 sampai 4 sampai tidak ada lagi input atau eof (end of file).

sed ini punya banyak mode untuk manipulasi stream. Di sini kita pelajari tiga saja yang umum dipakai.

    print. Print baris teks tanpa ada modifikasi teks.
    delete. Delete baris teks.
    subtitute. Cari pola karakter berdasarkan regex dan subtitusi karakter itu dengan karakter lain.

Print
Mode print dipakai buat print baris teks tanpa ada manipulasi teks.

Contoh dengan file data.txt yang seperti ini.

$ cat data.txt
1. satu
2. dua
3. tiga
4. empat
5. lima
6. enam
7. tujuh
8. delapan
9. sembilan
10. sepuluh

Format mode print: sed -n '<nomor baris>'p file.

Contoh print baris ke 7.

$ sed -n '7'p data.txt
7. tujuh

Print baris terakhir pakai tanda $ (dolar).

$ sed -n '$'p data.txt
10. sepuluh

Print baris ke dua sampai 5.

$ sed -n '2,5'p data.txt
2. dua
3. tiga
4. empat
5. lima

Print baris ke delapan sampai baris terakhir.

$ sed -n '8,$'p data.txt
8. delapan
9. sembilan
10. sepuluh

 

Delete
Format untuk mode delete: sed '<nomor baris>'d file.

Mode delete ini bisa dianggap kebalikan dari mode print.

Contoh delete baris ke 7.

$ sed '7'd data.txt
1. satu
2. dua
3. tiga
4. empat
5. lima
6. enam
8. delapan
9. sembilan
10. sepuluh

Delete baris terakhir pakai tanda $ (dolar).

$ sed '$'d data.txt
1. satu
2. dua
3. tiga
4. empat
5. lima
6. enam
7. tujuh
8. delapan
9. sembilan

Delete baris ke dua sampai 5.

$ sed '2,5'd data.txt
1. satu
6. enam
7. tujuh
8. delapan
9. sembilan
10. sepuluh

Delete baris ke delapan sampai baris terakhir.

$ sed -n '8,$'d data.txt
1. satu
2. dua
3. tiga
4. empat
5. lima
6. enam
7. tujuh

 

Subtitusi
Mode subtitusi ini bisa dibilang search and replace, cari karakter pakai regex, kalau ketemu replace.

Saya suka pakai sed mode ini, lebih cepat daripada harus lewat teks editor.

Format mode subtitusi: sed 's/regex/replace/' file

Dengan contoh file data.txt seperti di bawah,

$ cat > data.txt << EOF
> 123 abc
> EOF

Coba subtitusi karakter 123 dengan 456.

$ sed 's/123/456/' data.txt
456 abc

sed ini kalau kita instruksikan buat subtitusi karakter, cuma pattern yang pertama match saja yang dirubah.

$ cat > data.txt << EOF
> 123 abc 123
> EOF
$
$ sed 's/123/456/' data.txt
456 abc 123

Pattern 123 yang kedua tidak berubah. Kalau kita mau rubah semuanya, pakai g (global) setelah delimiter terakhir.

$ sed 's/123/456/g' data.txt
456 abc 456

Tentu saja sed ini juga bisa ambil input dari stdin selain file.

$ cat data.txt | sed 's/123/456/g'
456 abc 456

Dari semua contoh di atas itu, output semuanya di print ke stdout. Kadang kita perlu juga output bukan stdout tapi langsung ke file.
sed punya satu fitur untuk ini namanya in-place. Pakai in-place, input dan output adalah file yang sama. Gampangnya, edit file tanpa perlu buka di editor.

$ cat > data.txt << EOF
> 123 abc 123
> EOF

Merubah file secara in-place pakai argumen -i.

$ sed -i 's/123/456/' data.txt
$ cat data.txt
456 abc 123

 

Sampai sini topik kali ini, manipulasi teks dan stream.
Contoh-contoh yang ditulis di atas itu sedikit, cuma buat pengenalan. Kalau kurang, “Man page is your friend”, dan tentu saja Google.

Saya terbuka, jadi silahkan disampaikan kalau di tulisan ini ada yang perlu dikoreksi, perlu ditambah atau dikurangi, asal bukan untuk dihapus.

Sampai jumpa di tulisan selanjutnya, Insya Allah.




pengertian perintah awk

"Awk" adalah sebuah perintah pada Linux / Unix yang mempunyai kegunaan untuk mem-parsing atau mengurai sebuah file. Hampir mirip dengan "grep", namun bedanya grep digunakan ketika kita akan mem-filter sebuah isi direktori dengan sebuah ketentuan. awk paling sering digunakan untuk me-scan dan memproses sebuah pola. Pencarian pada sebuah file yang cocok dengan pola yang dibuat lalu menyaring pencarian tersebut kedalam sebuah file baru.

Berikut ini adalah fitur-fitur yang dimiliki Awk :
-Awk menjadikan text file sebagai records dan fields
-Seperti bahasa pemrograman lainnya, Awk mengandung variabel, kondisi, dan looping
-Awk mempunyai operator aritmatika dan string
-Awk bisa digenerate menjadi laporan yang berformat

contoh perintah default:
pertama kita buat file txt dengan nama terserah,disini saya menggunakan nama listhutang.txt dengan isi sebagai berikut:
Code:
1 sony 200000
2 nicolas 300000
3 amin 50000
4 yoga 10000
5 mizan 85000
berikut contoh perintah dan hasilnya:
Code:
pandora@pandorabox:~/awk$ awk '{print;}' listhutang.txt
1 sony 200000
2 nicolas 300000
3 amin 50000
4 yoga 10000
5 mizan 85000
contoh perintah menampilkan baris tertentu:
Code:
pandora@pandorabox:~/awk$ awk '/sony/' listhutang.txt
1 sony 200000
contoh perintah menampilkan field tertentu:
Code:
pandora@pandorabox:~/awk$ awk '{print $2,$3}' listhutang.txt
sony 200000
nicolas 300000
amin 50000
yoga 10000
mizan 85000
contoh perintah menampilkan jumlah paling banyak/terkecil berdasarkan field ke 3:
Code:
pandora@pandorabox:~/awk$ awk '{$3>90000}' listhutang.txt
1 sony 200000
2 nicolas 300000

contoh inisialisasi dan final action:
Awk memiliki 2 pola penting yang dibuat spesifik berdasarkan kata kunci yang disebut BEGIN dan END.

Syntax:
Code:
BEGIN { Actions}
{ACTION} # Action for everyline in a file
END { Actions }

# is for comments in Awk
contoh:
Code:
pandora@pandorabox:~/awk$ awk 'BEGIN {print "no\tnama\tjumlah";}
>{print $1,"\t",$2,"\t",$3,"\t";}
>END {print "----------------------"
>}'  listhutang.txt

untuk contoh pengembangan awk saya kasih contoh mengabungkan perintah awk dan grep untuk menganalisa file httpd.log pada sebuah server untuk membuat report tertentu:

pertama kita lihat format file yang akan kita proses
kira-kira format dari file httpd.log ini adalah:
Code:
1   2 3        4              5           6                     7            8                     9
ip  -  -  Date/time    timezone  Request type  Req content http response     size

Contoh mencari serangan sqli:

pertama kita masukan file httpd.log ke folder “workshop/sql”
lalu kita masuk ke dalam folder yang telah ditentukan dengan perintah “cd workshop/sql”
setelah masuk kita masukkan perintah di terminal :
Code:
pandora@pandorabox:~/workshop/sql$ for file in $(ls ~/workshop/sql); do awk '{print $1, $4, $6, $7}' $file |grep GET| grep -E "SELECT|UNION|select|union" > $file"_sqli_report.txt"; done
Contoh mencari serangan sqli:

pertama kita masukan file httpd.log ke folder “workshop/sql”
lalu kita masuk ke dalam folder yang telah ditentukan dengan perintah “cd workshop/sql”
setelah masuk kita masukkan perintah di terminal :
Code:
pandora@pandorabox:~/workshop/sql$ for file in $(ls ~/workshop/sql); do awk '{print $1, $4, $6, $7}' $file |grep GET| grep -E "SELECT|UNION|select|union" > $file"_sqli_report.txt"; done
keterangan:

script ini berarti list semua file dalam folder "~/workshop/sql" kemudian parse dengan awk dan ambil informasi yang diperlukan dimana $1 adalah ip address, $4 adalah DateTime, $6 adalah Request Type dan $7 adalah Request Content kemudian filter baris yang mengandung kata2 GET dan filter sekali lagi baris yang mengandung kata-kata select atau union yang mana merupakan kata-kata yang biasa digunakan dalam melakukan sql injection. lakukan parse dan filter pada setiap file yang dtemukan pada folder "~/workshop/sql" sampai habis. Lalu hasilnya dimasukan ke dalam nama yang diproses ditambah dengan imbuhan “_sqli_report.txt”(httpd.log_sqli_report.txt)

Contoh mencari serangan xss:

pertama kita masukan file httpd.log ke folder “workshop/xss”
lalu kita masuk ke dalam folder yang telah ditentukan dengan perintah “cd workshop/xss”
setelah masuk kita masukkan perintah di terminal :
Code:
for file in $(ls ~/workshop/xss); do awk '{print $1, $4, $6, $7}' $file |grep GET| grep -E "javascript" > $file"_xss_report.txt"; done

keterangan:
script ini berarti list semua file dalam folder "~/workshop/xss" kemudian parse dengan awk dan ambil informasi yang diperlukan dimana $1 adalah ip address, $4 adalah DateTime, $6 adalah Request Type dan $7 adalah Request Content kemudian filter baris yang mengandung kata-kata GET dan filter sekali lagi baris yang mengandung kata-kata javascript yang mana salah satu ciri serangan xss. lakukan parse dan filter pada setiap file yang dtemukan pada folder "~/workshop/xss" sampai habis. Lalu hasilnya dimasukan ke dalam nama yang diproses ditambah dengan imbuhan “_sqli_report.txt”(httpd.log_xss_report.txt)

Contoh mencari serangan directory jumping:

pertama kita masukan file httpd.log ke folder “workshop/dirjump”
lalu kita masuk ke dalam folder yang telah ditentukan dengan perintah “cd workshop/dirjump”
setelah masuk kita masukkan perintah di terminal :
Code:
for file in $(ls ~/workshop/dirjump); do awk '{print $1, $4, $6, $7}' "$file" |grep GET| grep -E "/etc|cmd.exe" > $file"_dirjump_report.txt"; done

keterangan:
Dengan script ini, bias dilakukan automatisasi pembuatan report tentang adanya directory jumping dari apache log. Script ini berarti list semua file dalam folder "~/workshop/dirjump" kemudian parse dengan awk dan ambil informasi yang diperlukan dimana $1 adalah ip address, $4 adalah DateTime, $6 adalah Request Type dan $7 adalah Request Content kemudian filter baris yang mengandung kata-kata GET dan filter sekali lagi baris yang mengandung /etc atau cmd.exe karena biasanya file-file yang dicari ada di folder /etc atau bisa diakses dengan cmd.exe.

Kita juga dapat melakukan pencacahan tentang ip mana yang melakukan jenis serangan sql injection/serangan yg lain dengan script/perintah berikut:
Code:
for file in $(ls ~/workshop/sqli_report); do awk '{print $1}' $file |sort|uniq -c|sort -n > $file"_stats.txt"; done
contoh menganalisis file secure.log

kita pertama-tama mencari log ssh yang berhasil login menggunakan script berikut ini
Code:
cat secure.log | sort | grep 'Accepted' | awk '{print $1 " " $2 " " $3 " User: " $9 " IP:" $11 }' > "ssh_log_success.txt"
lalu mencari log ssh yang gagal login dengan menggunakan script berikut ini
Code:
cat secure.log | sort | grep 'Failed' | awk '{print $1 " " $2 " " $3 " User: " $9 " IP:" $11 }' > "ssh_log_success.txt"

disini saya sertakan juga file httpd.log dan secure.log buat latihan .file nya bisa di download disini :d

kalo tutorialnya berkenan mungkin bisa bagi yang ijo2 nya Smile)Smile)